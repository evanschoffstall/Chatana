# Investigation: Migration to Microsoft Agent Framework (Semantic Kernel)

## 1. Executive Summary

This investigation explores the feasibility of migrating the Chatana extension from the current custom implementation (based on `@anthropic-ai/claude-agent-sdk`) to the **Microsoft Agent Framework** orchestration patterns.

**Conclusion:** **Feasible**. The "Microsoft Agent Framework" for TypeScript/JavaScript is implemented via the **Semantic Kernel** SDK (`semantic-kernel` on npm). While the JS SDK lags slightly behind the .NET version in terms of high-level "Agent" abstractions (like `AgentGroupChat`), it provides robust `Planner` and `Plugin` architectures that can replicate and potentially improve upon the current orchestrator logic.

## 2. Terminology Mapping

| Concept | Current Implementation (Chatana) | Microsoft Agent Framework (Semantic Kernel) |
| :--- | :--- | :--- |
| **Orchestrator** | Custom `OrchestratorAgent` class | `Kernel` + `Planner` (e.g., `FunctionCallingStepwisePlanner`) |
| **Agent Logic** | Manual `query()` loop + System Prompt | `Agent` class (experimental in JS) or `Kernel` instance |
| **Tools** | MCP Tools (custom implementation) | `KernelPlugin` (Functions) |
| **Memory** | Custom `MemoryManager` / `MemoryMcpServer` | `ISemanticTextMemory` / `VolatileMemoryStore` |
| **Workflow** | Hardcoded steps in `OrchestratorAgent.ts` | `Plan` object (generated by Planner) |

## 3. Implementation Analysis

### 3.1. Current Architecture
*   **Dependency:** `@anthropic-ai/claude-agent-sdk`
*   **Pattern:** The `OrchestratorAgent` manually maintains a conversation history, sends it to Claude, parses tool calls (`spawn_agent`, `create_workitem`), and executes them.
*   **Pros:** Complete control over the loop; lightweight.
*   **Cons:** Boilerplate code for tool handling; manual error recovery; "reinventing the wheel" for planning.

### 3.2. Proposed Architecture (Semantic Kernel)
*   **Dependency:** `semantic-kernel` (npm)
*   **Pattern:**
    1.  Initialize a `Kernel`.
    2.  Import existing MCP tools as **Plugins**.
    3.  Use a **Planner** (likely `FunctionCallingStepwisePlanner`) to automatically generate and execute a plan based on the user's goal.
*   **Pros:** Standardized orchestration; built-in support for "reasoning" via Planners; easier integration with other AI services (Azure OpenAI, etc.) if needed.
*   **Cons:** Heavier abstraction; JS SDK maturity issues (some features experimental); steep learning curve for "Plugins" vs simple "Tools".

## 4. Gap Analysis & Risks

### 4.1. JavaScript SDK Maturity
The Microsoft Agent Framework documentation heavily features .NET and Python. The JavaScript/TypeScript SDK (`semantic-kernel`) is active but sometimes lacks the higher-level "Multi-Agent" primitives (like `AgentGroupChat`) found in the .NET version.
*   **Mitigation:** We can implement the "Orchestrator" pattern using the `Planner` capabilities, which are stable in JS. We might need to build our own lightweight "Agent" wrapper around the Kernel to maintain the "Worker Agent" concept.

### 4.2. MCP Integration
Chatana relies on MCP. Semantic Kernel has experimental support for importing OpenAI plugins, but direct MCP support might require a custom adapter.
*   **Mitigation:** We can write a generic `McpPluginAdapter` that converts MCP tool definitions into Semantic Kernel Functions.

## 5. Migration Plan

If approved, the migration would follow these steps:

1.  **Dependencies:** Add `semantic-kernel` and remove `@anthropic-ai/claude-agent-sdk` (or keep parallel during transition).
2.  **Plugin Adapter:** Create a utility to convert `McpManager` tools into a `KernelPlugin`.
3.  **Refactor Orchestrator:**
    *   Replace `OrchestratorAgent.processTask()` logic.
    *   Instead of `query()`, instantiate a `Kernel`.
    *   Register the `OrchestratorTools` (spawn, workitems) as a Plugin.
    *   Use `FunctionCallingStepwisePlanner` to execute the user's request.
4.  **Refactor Worker Agents:**
    *   Update `AgentSession` to use a `Kernel` instance instead of raw API calls.
    *   This provides workers with better reasoning capabilities (via Planners) if needed.

## 6. Recommendation

**Proceed with Migration** if the goal is to align with industry standards and leverage a robust ecosystem. The "Planner" pattern in Semantic Kernel is a more robust way to handle the "Orchestrator" logic than the current manual loop.

**Hold** if the priority is keeping the extension lightweight and minimizing dependencies, as `semantic-kernel` adds significant weight compared to the thin Claude SDK.
